ライブラリの概要
================

日々のメールクライアントソフトウェアの大抵の機能はインターフェイスとしてオブジェクト指向の PHP コードを使うことで、Swift Mailer によって提供されます。

この章では全体で Swift Mailer ライブラリを形成しているさまざまなコンポーネントをさっと巡ります。この本の全体で使われる重要な用語を学び Swift Mailer をアプリケーションに統合するためのクラスの理解を少し得ます。

この章はこの本の続く章に含まれる情報のための準備をすることを意図しています。かなりの技術指向であれば、この章を飛ばすこともできますが、少なくともここでの行間を読めば長い目である程度の時間の節約になります。

システム要件
------------

Swift Mailer を動かす最小限の要件はごく最小のもので簡単に実現できます。歴史では、Swift Mailer は PHP 4 と PHP 5 の両方をサポートしていましたが、平行した開発ワークフローが続きました。第4番目のバージョンでは、 PHP 4 のサポートは作者の Zend によって[公式に][1]打ち切られたので、Swift Mailer は PHP 5.2 もしくはそれ以降の PHP が動くサーバーで動きます。

ライブラリは可能な限り PHP 5 のプロジェクトと連携できることを目的とします:

 * PHP 5.2 もしくはそれ以降で、SPL エクステンションつき (標準)

 * SMTP リモートサーバーへの接続にアクセスできる限定的なネットワーク権限

 * 8 MB もしくはそれ以上のメモリ制限 (Swift Mailer はおよそ 2 MB を使います)

コンポーネントの分析
-------------------

Swift Mailer は多くのクラスで構成されます。それぞれのクラスは実行するよう設計されたタスクを記述する一般的な "component" グループに分類されます。

この本のセクションでは Swift Mailer を形成するコンポーネントを手短に見ます。

### メーラー

メーラークラスの `Swift_Mailer` はほかのコンポーネントのすべてがお互いに面するライブラリの中心のクラスです。`Swift_Mailer` はメッセージディスパッチャーのソートとしてふるまい、すべての対象の受信者にメッセージを配信する内部のトランスポートとコミュニケーションします。

Swift Mailer のソースコードを掘り下げると `Swift_Mailer` 自身はとてもまばらであることがわかります。これはたいていのタスクと理論においてほかのオブジェクトに異常を行い、Swift Mailer の内部をよく知っている場合、このクラスを完全に回避できます。しかしながらこのようなことはおすすめしません &#8211; このクラスが存在する理由は複数あります:

  * 使われるトランスポートに関わらず、一貫性のために

  * 内部 API の変更が行われるイベントで内部から抽象化を提供するため

  * 内部 API の面の便利なラッパーを提供するため

`Swift_Mailer` のインスタンスはメッセージを送信する前に作られます。

### トランスポート

トランスポートはメッセージを配信するためにサーバーとコミュニケーションを行う責務を担う Swift Mailer のクラスです。Swift Mailer のトランスポートの種類はいくつかあります。これらすべては `Swift_Transport` インターフェイスを実装し内部で `start()`、`stop()` と `send()` メソッドを提供します。

大抵の場合トランスポートが水面下でどのように動くのか知る必要はありません。必要なのはこのインスタンスの作り方と、環境でどれを使えばよいのかだけを知ることだけです。 

| クラス | 機能     | よい点とわるい点 |
| ------ | -------- | --------------- |
| `Swift_SmtpTransport` | SMTP を通してメッセージを送信する; 認証をサポートする; 暗号化をサポートする | とてもポータブルである; 楽しく予測可能な結果; よいフィードバックを提供する |
| `Swift_SendmailTransport` | ローカルにインストールされた `sendmail` 実行ファイルとコミュニケーションする (Linux/UNIX) | すばやく動かせる; SMTP よりも不正確なフィードバックを提供する; `sendmail` のインストールが必要 |
| `Swift_MailTransport` | PHP の組み込み関数の `mail()` を使う | とてもポータブルである; 潜在的に予測不可能な結果; とても弱いフィードバックを提供する 
| `Swift_LoadBalancedTransport` | 負荷軽減を管理するほかのトランスポートのコレクションを通して循環を行う | トランスポートが機能しない場合グレースフルフォールバックを提供する (たとえば SMTP サーバーがダウンする); 仕事を分散することでリモートサービスでのロードを抑える |
| `Swift_FailoverTransport` | 高い利用可能性を提供するほかのトランスポートのコレクションと連携する | トランスポートが失敗する場合グレースフルフォールバックを提供する (たとえば SMTP サーバーがダウンする) |

### MIME エンティティ

メッセージの一部を形成するすべてのものは MIME エンティティと呼ばれます。Swift Mailer のすべての MIME エンティティは機能の共通セットを共有します。添付物や MIME 部分など異なる目的の用途を提供するさまざまな種類の MIME エンティティがあります。

メールメッセージは異なる結果を実現するために異なる方法で結びつけられた相対的にシンプルなエンティティで構成されます。これらのエンティティのすべては同じアウトラインを持ちますが異なる目的を提供します。メッセージ自身は MIME エンティティとして定義できます、添付は MIME エンティティで、すべての MIME 部分は MIME エンティティ &#8211; などです &#8230;

それぞれの MIME エンティティ &#8211 の基本単位hメッセージそのもの、もしくは添付 &#8211; はヘッダーとボディです:

    Other-Header: Another value

    The body content itself

MIME エンティティのヘッダーとボディはさまざまな RFC  ドキュメントで定義される厳しい標準に準拠しなければなりません。Swift Mailer はエンティティを生成するエンコーダーと異なる種類のヘッダー型を含めて、さまざまな種類のオブジェクトを使ってこれらの仕様がフォローされることを保証します。

それぞれの MIME コンポーネントは `Swift_Mime_MimeEntity` インターフェイスを実装し、ヘッダー取得する、新しいヘッダーを追加する、エンコーダーを変更する、ボディを更新するためなどのメソッドを提供します &#8230;

すべての MIME エンティティは共通で1つのヘッダー; Content-Type ヘッダーを持ちます &#8211。これはエンティティの `setContentType()` メソッドで更新できます。

### エンコーダー

エンコーダーは Swift Mailer によって生成されるメッセージの内容をインターネットにまたがって送信するのに安全で RFC の仕様に準拠するフォーマットに変換します。

一般的に言えば Swift Mailer のエンコーダーとやりとりする必要はありません &#8211; 正しい設定はライブラリ自身によって処理されます。しかしながらこれらで遊ぶ場合のためにこれらは手短に説明する価値があるでしょう。

すべての MIME エンティティのヘッダーとボディの両方 (メッセージ自身も含む) はこれらに含まれるデータが破損するもしくは誤解されることなくインターネットを通して送信できることを保証するエンコーダーを使います。2種類の エンコーダー: Base64 と Quoted-Printable があります。

### プラグイン

プラグインは Swift Mailer のふるまいを拡張もしくは修正するために存在します。これらは送信の間にトランスポートの範囲内で起動するイベントに対応します。

Swift Mailer のベースパッケージの一部として提供されるパッケージはたくさんありこれらすべてはライブラリの範囲内で起動するイベントに対応する共通のインターフェイスにしたがいます。インターフェイスはそれぞれの種類のイベントを"リスニングし"リスニングしているイベントが起きるときに望むようにふるまいます。

Swift Mailer によってそのまま使えるさまざまなプラグインが提供されているものの、イベントシステムはオブジェクト指向の経験を積んだ開発者が基本ライブラリでは実現できないかもしれないゴールを達成するために独自のプラグインを楽に書けるよう特に設計されました。

[1]: http://www.php.net/archive/2007.php#2007-07-13-1 "PHP 4 end of life announcement on php.net"
